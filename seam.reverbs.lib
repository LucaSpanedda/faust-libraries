sre = library("seam.reverbs.lib");
ma = library("maths.lib");
de = library("delays.lib");

// -----------------------------------------------------------------------------
// SCHROEDER NATURAL SOUNDING REVERBS - 1962

// delay feedback in loop
dfl(t,g) = (+ : @(t))~*(g);
//process = dfl(1,0.5);

// correct delay feedback in loop
dflc(t,g) = (+ : @(t-1))~*(g) : mem;
//process = dfl(1,0.5);

// correct delay feedback in loop complex
dflcc(t,g) = (+ : de.delay(ma.SR/2, int(t-1)))~*(max(0, min(0.999, g))) : mem;
//process = dfl(1,0.5);

// all-pass filter
apf(t,g) = _ <: (*(ma.neg(max(0, min(0.999, g)))))+(dflcc(t,g)*(1-(g*g)));
//process = os.impulse : apf(1,0.5);

schrev = _ <: // to 4 parallel comb
  dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708) :>
  apf(307,0.708) : apf(881,0.708); // and a sequence of two allpass

revsch = apf(307,0.708) : apf(881,0.708) <: // two allpass to 4 comb
  dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708);

// commutability test
//process = os.impulse <: schrev, (revsch :> _);

matrix = apf(47,0.708), apf(41,0.708), apf(31,0.708), apf(23,0.708),
         apf(17,0.708), apf(11,0.708), apf(5,0.708), apf(2,0.708),
         apf(3,0.708), apf(7,0.708), apf(13,0.708), apf(19,0.708),
         apf(29,0.708), apf(37,0.708), apf(43,0.708), apf(53,0.708);

//ambiorev = revsch <: par(i, 4, _<:_,ma.neg) : matrix;

ambiorev = (revL <: phase), (revR <: phase) <: matrix
with{
  revL = apf(281,0.708) : apf(4051,0.708) : apf(307,0.708) : apf(881,0.708) <:
         dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708);
  revR = apf(271,0.708) : apf(4201,0.708) : apf(311,0.708) : apf(877,0.708) <:
         dflc(4111,0.708), dflc(4159,0.708), dflc(7309,0.708), dflc(2819,0.708);
  phase = par(i, 4, _<:_,ma.neg);
  matrix = apf(47,0.708), apf(41,0.708), apf(31,0.708), apf(23,0.708),
           apf(17,0.708), apf(11,0.708), apf(5,0.708), apf(2,0.708),
           apf(3,0.708), apf(7,0.708), apf(13,0.708), apf(19,0.708),
           apf(29,0.708), apf(37,0.708), apf(43,0.708), apf(53,0.708);
};

//process = ambiorev :> _,_;

// DA SISTEMARE ------------
//import("stdfaust.lib");
// comb
dfl(t,g) = + @(t-1) ~ *(g) : mem;
// all-pass
apf(t,g) = _ <: *(-g) + (dfl(t,g) : *(1-(g*g)));
// all-pass prime numbers reverb
aprev = apf(3001,0.708) : apf(3011,0.708) : apf(163,0.85) : apf(4177,0.4) : apf(1447,0.8) : apf(5953,0.708);
// golden ratio
phi = (1+(sqrt(5)))/2;
// phi-tuned all-pass reverb
apphirev(N,t) = seq(i,N, apf(int(t*(i+1)*phi),0.708));
// process = apphirev(53,61);
//process = _ <: apphirev(53,61), apphirev(53,59);

// unused
som(N) = (N*(N+1))/2;
apphirevn(N,t) = seq(i,N,apf(int(t*(i+1)*phi),(i+1)*(1/som(N)))); //troppo asciutto
dapphirev(N,t,g,pd) =_ <: *(-g) + ((+ : @ (pd) : apphirev (N,t))~ *(g) : *(1-(g*g)));
//-----------------------------

// -----------------------------------------------------------------------------
// MOORER - SIGNAL PROCESSING ASPECTS OF COMPUTER MUSIC - A SURVEY - 1977

jmcomb(d,g) = + ~ @(d-1)*(g);
jmcosc(d,g,theta) = + ~ (@(d-1) <: *(2*g*(cos(theta))) + @(d)*(ma.neg(g*g)));
//process = os.impulse : jmcosc(1,0.708,a);

jmapf(d,g) = (+ <: @(d-1), *(-g)) ~ *(g) : mem , _ : +;
//process = os.impulse : jmapf(1,0.9);

jmapfosc(d,g,theta) = (+ <: z1(d,g,theta), *(g*g) : @(d-1),_,_)~*(ma.neg(g*g)) : mem,_,_:> _
with{
    z1(d,g,theta) = (+ : @(d-1)) ~ *(2*g*cos(theta)) : (mem <: _,*(ma.neg(2*g*cos(theta))));
};
//process = os.impulse : jmapfosc (1,1,a) * (0.03);
//process = os.impulse <: jmcombosc(1,1,a) * (0.03), jmapfosc(1,1,a) * (0.03);

// -----------------------------------------------------------------------------
// FAUST LIBRARIES - CARGO CALL
an = library("analyzers.lib");
ba = library("basics.lib");
co = library("compressors.lib");
de = library("delays.lib");
dm = library("demos.lib");
dx = library("dx7.lib");
en = library("envelopes.lib");
fi = library("filters.lib");
ho = library("hoa.lib");
it = library("interpolators.lib");
ma = library("maths.lib");
mi = library("mi.lib");
ef = library("misceffects.lib");
os = library("oscillators.lib");
no = library("noises.lib");
pf = library("phaflangers.lib");
pl = library("platform.lib");
pm = library("physmodels.lib");
rm = library("reducemaps.lib");
re = library("reverbs.lib");
ro = library("routes.lib");
sp = library("spats.lib");
si = library("signals.lib");
so = library("soundfiles.lib");
sy = library("synths.lib");
ve = library("vaeffects.lib");
wa = library("webaudio.lib");
sf = library("all.lib");
vl = library("version.lib");
