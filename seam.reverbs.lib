sre = library("seam.reverbs.lib");
ma = library("maths.lib");
de = library("delays.lib");

// -----------------------------------------------------------------------------
// SCHROEDER NATURAL SOUNDING REVERBS - 1962

// delay feedback in loop
dfl(t,g) = (+ : @(t))~*(g);
//process = dfl(1,0.5);

// correct delay feedback in loop
dflc(t,g) = (+ : @(t-1))~*(g) : mem;
//process = dfl(1,0.5);

// correct delay feedback in loop complex
dflcc(t,g) = (+ : de.delay(ma.SR/2, int(t-1)))~*(max(0, min(0.999, g))) : mem;
//process = dfl(1,0.5);

// all-pass filter
apf(t,g) = _ <: (*(ma.neg(max(0, min(0.999, g)))))+(dflcc(t,g)*(1-(g*g)));
//process = os.impulse : apf(1,0.5);

schrev = _ <: // to 4 parallel comb
  dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708) :>
  apf(307,0.708) : apf(881,0.708); // and a sequence of two allpass

revsch = apf(307,0.708) : apf(881,0.708) <: // two allpass to 4 comb
  dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708);

// commutability test
//process = os.impulse <: schrev, (revsch :> _);

matrix = apf(47,0.708), apf(41,0.708), apf(31,0.708), apf(23,0.708),
         apf(17,0.708), apf(11,0.708), apf(5,0.708), apf(2,0.708),
         apf(3,0.708), apf(7,0.708), apf(13,0.708), apf(19,0.708),
         apf(29,0.708), apf(37,0.708), apf(43,0.708), apf(53,0.708);

//ambiorev = revsch <: par(i, 4, _<:_,ma.neg) : matrix;

ambiorev = (revL <: phase), (revR <: phase) <: matrix
with{
  revL = apf(281,0.708) : apf(4051,0.708) : apf(307,0.708) : apf(881,0.708) <:
         dflc(4133,0.708), dflc(4157,0.708), dflc(7307,0.708), dflc(2803,0.708);
  revR = apf(271,0.708) : apf(4201,0.708) : apf(311,0.708) : apf(877,0.708) <:
         dflc(4111,0.708), dflc(4159,0.708), dflc(7309,0.708), dflc(2819,0.708);
  phase = par(i, 4, _<:_,ma.neg);
  matrix = apf(47,0.708), apf(41,0.708), apf(31,0.708), apf(23,0.708),
           apf(17,0.708), apf(11,0.708), apf(5,0.708), apf(2,0.708),
           apf(3,0.708), apf(7,0.708), apf(13,0.708), apf(19,0.708),
           apf(29,0.708), apf(37,0.708), apf(43,0.708), apf(53,0.708);
};

//process = ambiorev :> _,_;

// DA SISTEMARE ------------
//import("stdfaust.lib");
// comb
dfl(t,g) = + @(t-1) ~ *(g) : mem;
// all-pass
apf(t,g) = _ <: *(-g) + (dfl(t,g) : *(1-(g*g)));
// all-pass prime numbers reverb
aprev = apf(3001,0.708) : apf(3011,0.708) : apf(163,0.85) : apf(4177,0.4) : apf(1447,0.8) : apf(5953,0.708);
// golden ratio
phi = (1+(sqrt(5)))/2;
// phi-tuned all-pass reverb
apphirev(N,t) = seq(i,N, apf(int(t*(i+1)*phi),0.708));
// process = apphirev(53,61);
//process = _ <: apphirev(53,61), apphirev(53,59);

// unused
som(N) = (N*(N+1))/2;
apphirevn(N,t) = seq(i,N,apf(int(t*(i+1)*phi),(i+1)*(1/som(N)))); //troppo asciutto
dapphirev(N,t,g,pd) =_ <: *(-g) + ((+ : @ (pd) : apphirev (N,t))~ *(g) : *(1-(g*g)));
//-----------------------------

// -----------------------------------------------------------------------------
// MOORER - SIGNAL PROCESSING ASPECTS OF COMPUTER MUSIC - A SURVEY - 1977

jmcomb(d,g) = + ~ @(d-1)*(g);
jmcosc(d,g,theta) = + ~ (@(d-1) <: *(2*g*(cos(theta))) + @(d)*(ma.neg(g*g)));
//process = os.impulse : jmcosc(1,0.708,a);

jmapf(d,g) = (+ <: @(d-1), *(-g)) ~ *(g) : mem , _ : +;
//process = os.impulse : jmapf(1,0.9);

jmapfosc(d,g,theta) = (+ <: z1(d,g,theta), *(g*g) : @(d-1),_,_)~*(ma.neg(g*g)) : mem,_,_:> _
with{
    z1(d,g,theta) = (+ : @(d-1)) ~ *(2*g*cos(theta)) : (mem <: _,*(ma.neg(2*g*cos(theta))));
};
//process = os.impulse : jmapfosc (1,1,a) * (0.03);
//process = os.impulse <: jmcombosc(1,1,a) * (0.03), jmapfosc(1,1,a) * (0.03);

// -----------------------------------------------------------------------------
// JON DATTORRO - EFFEC DESIGN PART 1. REVERBERATOR AND OTHER FILTERS - 1996

jondattorro_rev = pdly(0) : lp1p(bandwidth) : inputdiffusers <: tank
with{
  // reverberation parameters defaults
  excursion = hslider("[01]EXCURSION", 16, 0, 1024, 1) : int;
  decay = hslider("[02]DECAY", 0.5, 0, 1, 0.001) : si.smoo;
  dd1 = hslider("[03]DECAY DIFFUSION 1", 0.7, 0, 0.999, 0.001) : si.smoo;
  dd2 = hslider("[04]DECAY DIFFUSION 2", 0.5, 0, 0.999, 0.001) : si.smoo;
  id1 = hslider("[05]INPUT DIFFUSION 1", 0.750, 0, 0.999, 0.001) : si.smoo;
  id2 = hslider("[06]INPUT DIFFUSION 2", 0.625, 0, 0.999, 0.001) : si.smoo;
  bandwidth = hslider("[07]BANDWIDTH", 0.9995, 0.0001, 0.9999999, 0.0000001);
  damping = hslider("[08]DAMPING", 0.0005, 0, 0.999, 0.001);

  // predelay
  predelay = hslider("[00]PREDELAY", 0, 0, 8192, 1) : int;
  pdly(t) = de.delay(ma.SR/2,predelay);

  // filters
  lp1p(a) = *(a) : + ~ *(1-a);
  dflc(t,g) = (+ : de.delay(ma.SR/2,(t-1))) ~ *(g) : mem;
  apf(t,g) = _<: *(-g) + (dflc(t,g) *(1-(g*g)));

  // reverberators
  inputdiffusers = apf(142,id1) : apf(107,id1) : apf(379,id2) : apf(277,id2);
  xsec1(dmp) = (+ : apf(672+excursion,dd1) : @(4453) : lp1p(1-damping) : *(decay) : apf(1800,0.85) : @(3720) : *(decay));
  xsec2(dmp) = (+ : apf(908+excursion,dd2) : @(4217) : lp1p(1-damping) : *(decay) : apf(2656,0.85) : @(3163) : *(decay));
  xfbk = _,_;
  xroute(a,b,c,d) = a,c,b,d;
  tank = (xroute : xsec1(damping), xsec2(damping)) ~ xfbk;
};


// -----------------------------------------------------------------------------
// FAUST LIBRARIES - CARGO CALL
an = library("analyzers.lib");
ba = library("basics.lib");
co = library("compressors.lib");
de = library("delays.lib");
dm = library("demos.lib");
dx = library("dx7.lib");
en = library("envelopes.lib");
fi = library("filters.lib");
ho = library("hoa.lib");
it = library("interpolators.lib");
ma = library("maths.lib");
mi = library("mi.lib");
ef = library("misceffects.lib");
os = library("oscillators.lib");
no = library("noises.lib");
pf = library("phaflangers.lib");
pl = library("platform.lib");
pm = library("physmodels.lib");
rm = library("reducemaps.lib");
re = library("reverbs.lib");
ro = library("routes.lib");
sp = library("spats.lib");
si = library("signals.lib");
so = library("soundfiles.lib");
sy = library("synths.lib");
ve = library("vaeffects.lib");
wa = library("webaudio.lib");
sf = library("all.lib");
vl = library("version.lib");
